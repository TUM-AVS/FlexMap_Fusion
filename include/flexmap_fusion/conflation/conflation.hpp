// Copyright 2023 Maximilian Leitenstern
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ========================================== //
// Author: Maximilian Leitenstern (TUM)
// Date: 12.05.2023
// ========================================== //
//
//
#pragma once
//
#include "utility.hpp"

#include <Eigen/Dense>
#include <rclcpp/rclcpp.hpp>

#include <lanelet2_core/LaneletMap.h>
#include <lanelet2_core/geometry/Lanelet.h>
#include <lanelet2_core/geometry/LineString.h>
#include <lanelet2_core/geometry/Point.h>

#include <string>
#include <utility>
#include <vector>

class cconflation
{
public:
  cconflation();

  /************************************************************************
   * Remove tags from points that are auto-generated by VectorMapBuilder
   *************************************************************************/
  bool remove_tags(lanelet::LaneletMapPtr & map_ptr);

  /***********************************************************************************
   * Conflate information from OpenStreetMap into existing lanelet map:
   * -> map highway tag from osm to subtype and location tags in lanelet2
   * -> transfer maxspeed tag from osm to speed_limit tag
   * -> transfer name tag from osm to road_name tag
   * -> transfer surface tag from osm to road_surface tag
   * -> transfer oneway tag from osm to one_way tag
   * -> transfer lane_markings tag from osm to lane_markings tag
   * -> colorize lanelets based on accordance between adjacent lanelets (sharing
   * common boundary) and lanes tag in osm
   ************************************************************************************/
  bool conflate_lanelet_OSM(
    lanelet::LaneletMapPtr & map_ptr, std::vector<s_match> & matches,
    std::vector<std::pair<lanelet::Id, std::string>> & cols, lanelet::ConstLanelets & deleted);

  /**********************************************************************************
   * Create new map with all elements from map_ptr (original map) except the
   * deleted lanelets (no remove option in lanelet2 library)
   ***********************************************************************************/
  bool create_updated_map(
    const lanelet::LaneletMapPtr & map_ptr, const lanelet::LaneletMapPtr & new_map,
    const lanelet::ConstLanelets & deleted);

private:
  /******************************************************************************
   * Split all adjacent lanelets where a certain tag in openstreetmap changes
   *******************************************************************************/
  void split_on_tag_change(
    lanelet::LaneletMapPtr & map_ptr, s_match & match, const std::vector<std::string> & target_keys,
    std::vector<lanelet::ConstPoints3d> & pts_change,
    std::vector<std::vector<std::string>> & values);

  /************************************************************************
   * Derive lanelet subtype and location based on custom mapping from
   * openstreetmap's highway-tag
   *************************************************************************/
  void set_type_location(
    lanelet::LaneletMapPtr & map_ptr, const s_match & match,
    const lanelet::ConstPoints3d & pts_change, std::vector<std::string> & values);

  /********************************************************************************
   * Transfer attribute from openstreetmap to lanelet2-map
   * => transfer attribute
   *********************************************************************************/
  void transfer_att(
    lanelet::LaneletMapPtr & map_ptr, const s_match & match, const std::string & ref_key,
    const lanelet::ConstPoints3d & pts_change, std::vector<std::string> & values);

  /***********************************************************************************
   * Compare amount of adjacent lanelets (sharing a boundary) in lanelet-map to
   * openstreetmap's lanes tag if available
   * => colorize lanelet in RVIZ based on results (correct = green, wrong = red,
   * no lanes tag = blue, no match = white)
   ************************************************************************************/
  void check_lanes(
    const lanelet::LaneletMapPtr & map_ptr, s_match & match,
    std::vector<std::pair<lanelet::Id, std::string>> & cols,
    const lanelet::ConstPoints3d & pts_change_lanes,
    const lanelet::ConstPoints3d & pts_change_shoulder, std::vector<std::string> & val_lanes,
    std::vector<std::string> & val_shoulder, lanelet::ConstLanelets & deleted);

  /*******************************************************************************
   * Check if a an attribut of a polyline that exists at the beginning changes
   ********************************************************************************/
  void check_tag_change(
    const lanelet::LineStrings3d & pline, const std::vector<std::string> & keys,
    std::vector<lanelet::ConstPoints3d> & pts, std::vector<std::vector<std::string>> & values);

  /********************************************************************************
   * Split lanelets at desired points (point projected on lanelet-bounds)
   *********************************************************************************/
  void split_lanelet(
    lanelet::LaneletMapPtr & map_ptr, s_match & match, const lanelet::ConstPoints3d & pts);

  /*****************************************************************************
   * Split lanelets for forward/backward-direction of reference polyline
   * => split left and right bound and create new lanelet
   ******************************************************************************/
  void split_ll_dir(
    const lanelet::LaneletMapPtr & map_ptr, s_match & match, const int & ind,
    const std::string & key, lanelet::Ids & splitted, lanelet::LineStrings3d & newls,
    const lanelet::ConstPoint3d & pt);

  /**********************************************************************
   * Split linestring if it has been splitted so far
   * => project point to linestring and divide points to two ls
   ***********************************************************************/
  void split_linestring(
    lanelet::LineString3d & orig_ls, lanelet::LineString3d & new_ls, lanelet::Ids & splitted,
    lanelet::LineStrings3d & new_lss, const lanelet::ConstPoint3d & pt, const bool & invert);

  /***************************************************************************
   * Transfer attribute values for a given match
   ****************************************************************************/
  void transfer_tag(
    const s_match & match, const std::string & key_ref, const std::vector<int> & ind_change,
    std::vector<std::string> & values, lanelet::LaneletMapPtr & map_ptr, lanelet::Ids & setll);

  /***************************************************************
   * Get index of point in match reference pline
   ****************************************************************/
  int get_index(const s_match & match, const lanelet::ConstPoint3d & pt);

  /*********************************************************
   * Find a lanelet in a vector of lanelets given its id
   **********************************************************/
  lanelet::Lanelet find_ll(const lanelet::LaneletMapPtr & map_ptr, const lanelet::Id & id);

  /*********************************************************
   * Find a lanelet in a vector of lanelets given its bounds
   **********************************************************/
  lanelet::Lanelet find_ll_from_bound(
    const lanelet::LaneletMapPtr & map_ptr, const lanelet::LineString3d & left,
    const lanelet::LineString3d & right);

  /***********************************************************************************
   * Find the segment of a linestring a given projected point is in between
   ************************************************************************************/
  int find_segment_2D(const lanelet::ConstPoint3d & pt, const lanelet::LineString3d & ls);

  /******************************************************************
   * Remove attributes from a given point specified by the keys
   *******************************************************************/
  void remove_attributes(lanelet::Point3d & pt, const std::vector<std::string> & names);

  /*****************************************************************************
   * Check if a lanelet id is already present in the vector with color codes
   ******************************************************************************/
  bool used_Id(
    std::vector<std::pair<lanelet::Id, std::string>> & cols, const lanelet::Lanelet & ll);

  /*********************************************
   * Check if a linestring was already used
   **********************************************/
  bool used_Id(const lanelet::Ids & ids, const lanelet::LineString3d & ls);

  /*********************************************
   * Check if a lanelet was already used
   **********************************************/
  bool used_Id(const lanelet::Ids & ids, const lanelet::Lanelet & ll);

  /*********************************************
   * Get lanelets of a given map
   **********************************************/
  lanelet::Lanelets lanelet_layer(const lanelet::LaneletMapPtr & map_ptr);

  /****************************************************************
   * Check if the two plines of a match are in the same direction
   *****************************************************************/
  bool same_direction(const s_match & match);

  /**********************************************************************************
   * Set new attribute value for all forward/backward lanelets that are represented
   * by a linestring segment
   ***********************************************************************************/
  void set_value_dir(
    const std::string & key, const lanelet::LineString3d & seg,
    const lanelet::LaneletMapPtr & map_ptr, const std::string & key_ref, const std::string & val,
    lanelet::Ids & setll);

  /**************************************************************************************
   * Count lanelets represented by a linestring segment in forward/backward direction
   ***************************************************************************************/
  void count_lanes_dir(const std::string & key, const lanelet::LineString3d & seg, int & count);

  /***********************************************************************************
   * Set color code for all forward/backward lanelets that are represented by a
   * linestring segment
   ************************************************************************************/
  void set_color_code_dir(
    const std::string & key, const lanelet::LineString3d & seg,
    const lanelet::LaneletMapPtr & map_ptr, const std::string & col_code,
    std::vector<std::pair<lanelet::Id, std::string>> & cols);

  /*****************************************************************************************
   * Get lanelet subtype and location from openstreetmap's highway tag (custom definition)
   * -> see Readme for further explanation
   ******************************************************************************************/
  void highway2subtype_location(
    const std::string & val_osm, std::string & subtype, std::string & location);

  /************************************************************************************
   * Detect lonely lanelets that are wrongly mapped and hence not transferred to
   * output map based on:
   * -> no accordance between current osm-lanes tag and adjacent lanes
   * -> lanelet has neither predeccessor nor successor
   *************************************************************************************/
  bool find_wrong_lanelet(
    const lanelet::LaneletMapPtr & map_ptr, lanelet::LineString3d & seg,
    lanelet::ConstLanelets & deleted, s_match & match);

  /************************************************************************************
   * Detect lonely lanelets in direction => see findLonelyLanelet for more details
   *************************************************************************************/
  void find_wrong_lanelet_candidates(
    const lanelet::LaneletMapPtr & map_ptr, lanelet::LineString3d & seg, lanelet::Lanelets & cand);

  /***************************************************************
   * Merge vector of a vector of points to a single vector
   ****************************************************************/
  lanelet::ConstPoints3d merge_point_vec(std::vector<lanelet::ConstPoints3d> & pts_change);
};
